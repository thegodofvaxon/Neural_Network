// --- Collections & utilities ---
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.Arrays;
import java.util.Random;
import java.util.Collections;

// --- GUI ---
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

// --- IO ---
import java.io.*;

public class DigitRecognizer {

    // --- Activation functions ---
    public static double relu(double x) { return Math.max(0, x); }
    public static double reluDerivative(double x) { return x > 0 ? 1 : 0; }

    public static double[] softmax(double[] x) {
        double max = Arrays.stream(x).max().getAsDouble();
        double sum = 0.0;
        double[] exp = new double[x.length];
        for (int i = 0; i < x.length; i++) {
            exp[i] = Math.exp(x[i] - max);
            sum += exp[i];
        }
        for (int i = 0; i < x.length; i++) exp[i] /= sum;
        return exp;
    }

    // --- Forward pass ---
    public static Map<String, Object> forward(double[] input, double[][] w1, double[] b1,
                                              double[][] w2, double[] b2,
                                              double[][] w3, double[] b3, boolean training) {
        int h1 = w1[0].length;
        int h2 = w2[0].length;
        int outputSize = w3[0].length;

        double[] hidden1Raw = new double[h1];
        double[] hidden1 = new double[h1];
        for (int j = 0; j < h1; j++) {
            double sum = b1[j];
            for (int i = 0; i < input.length; i++) sum += input[i] * w1[i][j];
            hidden1Raw[j] = sum;
            hidden1[j] = relu(sum);
        }

        double dropoutRate = 0.2;
        if (training) {
            Random rand = new Random();
            for (int j = 0; j < h1; j++) if (rand.nextDouble() < dropoutRate) hidden1[j] = 0;
        }

        double[] hidden2Raw = new double[h2];
        double[] hidden2 = new double[h2];
        for (int j = 0; j < h2; j++) {
            double sum = b2[j];
            for (int i = 0; i < h1; i++) sum += hidden1[i] * w2[i][j];
            hidden2Raw[j] = sum;
            hidden2[j] = relu(sum);
        }

        if (training) {
            Random rand = new Random();
            for (int j = 0; j < h2; j++) if (rand.nextDouble() < dropoutRate) hidden2[j] = 0;
        }

        double[] outputRaw = new double[outputSize];
        for (int k = 0; k < outputSize; k++) {
            double sum = b3[k];
            for (int j = 0; j < h2; j++) sum += hidden2[j] * w3[j][k];
            outputRaw[k] = sum;
        }

        double[] output = softmax(outputRaw);

        Map<String, Object> res = new HashMap<>();
        res.put("hidden1", hidden1); res.put("hidden1Raw", hidden1Raw);
        res.put("hidden2", hidden2); res.put("hidden2Raw", hidden2Raw);
        res.put("output", output); res.put("outputRaw", outputRaw);
        return res;
    }
    public static double[] computePerDigitAccuracy(List<double[]> inputs, List<Integer> labels,
                                               double[][] w1, double[] b1,
                                               double[][] w2, double[] b2,
                                               double[][] w3, double[] b3) {
    double[] digitCorrect = new double[10];
    double[] digitTotal   = new double[10];

    for (int i = 0; i < inputs.size(); i++) {
        Map<String, Object> f = forward(inputs.get(i), w1, b1, w2, b2, w3, b3, false);
        double[] out = (double[]) f.get("output");

        // find predicted digit
        int pred = 0; double max = out[0];
        for (int j = 1; j < out.length; j++) {
            if (out[j] > max) { max = out[j]; pred = j; }
        }

        int label = labels.get(i);
        digitTotal[label]++;
        if (pred == label) digitCorrect[label]++;
    }

    double[] perDigitAcc = new double[10];
    for (int i = 0; i < 10; i++) {
        perDigitAcc[i] = digitTotal[i] > 0 ? digitCorrect[i] / digitTotal[i] : 0.0;
    }
    return perDigitAcc;
}

    // --- CSV loading ---
    public static List<double[]> loadInputs(String filename, int inputSize) throws IOException {
        List<double[]> inputs = new ArrayList<>();
        BufferedReader br = new BufferedReader(new FileReader(filename));
        String line = br.readLine(); // skip header
        while ((line = br.readLine()) != null) {
            String[] tokens = line.split(",");
            double[] input = new double[inputSize];
            for (int i = 0; i < inputSize; i++) input[i] = Double.parseDouble(tokens[i]) / 255.0;
            inputs.add(input);
        }
        br.close();
        return inputs;
    }

    public static List<Integer> loadLabels(String filename, int inputSize) throws IOException {
        List<Integer> labels = new ArrayList<>();
        BufferedReader br = new BufferedReader(new FileReader(filename));
        String line = br.readLine(); // skip header
        while ((line = br.readLine()) != null) {
            String[] tokens = line.split(",");
            labels.add(Integer.parseInt(tokens[inputSize]));
        }
        br.close();
        return labels;
    }

    // --- Save/Load weights ---
    public static void saveWeights(String filename, double[][] w1, double[] b1,
                                   double[][] w2, double[] b2,
                                   double[][] w3, double[] b3) throws IOException {
        try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(filename))) {
            out.writeObject(w1); out.writeObject(b1);
            out.writeObject(w2); out.writeObject(b2);
            out.writeObject(w3); out.writeObject(b3);
        }
    }

    public static Object[] loadWeights(String filename) throws IOException, ClassNotFoundException {
        try (ObjectInputStream in = new ObjectInputStream(new FileInputStream(filename))) {
            double[][] w1 = (double[][]) in.readObject(); double[] b1 = (double[]) in.readObject();
            double[][] w2 = (double[][]) in.readObject(); double[] b2 = (double[]) in.readObject();
            double[][] w3 = (double[][]) in.readObject(); double[] b3 = (double[]) in.readObject();
            return new Object[]{w1, b1, w2, b2, w3, b3};
        }
    }

    // --- Evaluate on any dataset & log ---
    public static double evaluateTestSet(List<double[]> inputs, List<Integer> labels,
                                         double[][] w1, double[] b1,
                                         double[][] w2, double[] b2,
                                         double[][] w3, double[] b3,
                                         BufferedWriter csv, int epoch, String datasetLabel) throws IOException {

        int correct = 0;
        double[] digitCorrect = new double[10];
        double[] digitTotal = new double[10];

        for(int i=0; i<inputs.size(); i++){
            Map<String,Object> f = forward(inputs.get(i), w1, b1, w2, b2, w3, b3, false);
            double[] out = (double[]) f.get("output");
            int pred = 0;
            double max = out[0];
            for(int j=1;j<out.length;j++){
                if(out[j]>max){ max=out[j]; pred=j; }
            }
            int label = labels.get(i);
            if(pred==label) correct++;
            digitTotal[label]++;
            if(pred==label) digitCorrect[label]++;
        }

        double acc = correct*1.0/inputs.size();
        double[] perDigitAcc = new double[10];
        for(int i=0;i<10;i++) perDigitAcc[i] = digitCorrect[i] / Math.max(1.0, digitTotal[i]);

        System.out.printf("Epoch %d %s: Total Accuracy %.2f%%%n", epoch, datasetLabel, acc*100.0);

        // Log to CSV
        csv.write(epoch + "," + datasetLabel + "," + acc);
        for(int i=0;i<10;i++) csv.write("," + perDigitAcc[i]);
        csv.write("\n");
        csv.flush();

        return acc;
    }

public static class AccuracyVisualizer extends JPanel {
    private final java.util.List<Double> totalAcc = new ArrayList<>();
    private final java.util.List<Double> testAcc = new ArrayList<>();
    private final java.util.List<Double> test1Acc = new ArrayList<>();
    private final java.util.List<double[]> perDigitAcc = new ArrayList<>();
    
    public void update(int epoch, double total, double test, double test1, double[] perDigit) {
        totalAcc.add(total);
        testAcc.add(test);
        test1Acc.add(test1);
        perDigitAcc.add(Arrays.copyOf(perDigit, perDigit.length));
        repaint();
    }

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);

        // Background gray
        g.setColor(Color.DARK_GRAY);
        g.fillRect(0, 0, getWidth(), getHeight());

        if (totalAcc.isEmpty()) return;

        Graphics2D g2 = (Graphics2D) g;
        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

        int w = getWidth(), h = getHeight();
        int margin = 50;
        int graphW = w - 2 * margin, graphH = h - 2 * margin;

        // Draw axes
        g2.setColor(Color.BLACK);
        g2.drawLine(margin, h - margin, margin, margin);
        g2.drawLine(margin, h - margin, w - margin, h - margin);

        int n = totalAcc.size();

        // Helper to draw one series (dots not connected)
        java.util.function.BiConsumer<List<Double>, Color> drawDots = (list, color) -> {
            g2.setColor(color);
            for (int i = 0; i < list.size(); i++) {
                if (n < 2) return; // avoid division by zero
                int x = margin + i * graphW / (n - 1);
                int y = (int) (h - margin - list.get(i) * graphH);
                g2.fillOval(x - 4, y - 4, 8, 8);
            }
        };

        // Plot total, test, test1
        drawDots.accept(totalAcc, Color.YELLOW);
        drawDots.accept(testAcc, Color.CYAN);
        drawDots.accept(test1Acc, Color.MAGENTA);

        // Per-digit accuracy (0–9), connected lines
        Color[] digitColors = {Color.RED, Color.BLUE, Color.GREEN, Color.ORANGE, Color.PINK,
                Color.LIGHT_GRAY, Color.MAGENTA, Color.CYAN, Color.WHITE, new Color(128, 0, 128)};
        for (int d = 0; d < 10; d++) {
            g2.setColor(digitColors[d % digitColors.length]);
            for (int i = 1; i < perDigitAcc.size(); i++) {
                int x1 = margin + (i - 1) * graphW / (n - 1);
                int y1 = (int) (h - margin - perDigitAcc.get(i - 1)[d] * graphH);
                int x2 = margin + i * graphW / (n - 1);
                int y2 = (int) (h - margin - perDigitAcc.get(i)[d] * graphH);
                g2.drawLine(x1, y1, x2, y2);
            }
        }

        // Legend
        g2.setColor(Color.WHITE);
        g2.drawString("Legend:", w - margin - 150, margin + 20);
        g2.setColor(Color.YELLOW); g2.fillRect(w - margin - 150, margin + 30, 10, 10);
        g2.setColor(Color.WHITE); g2.drawString("Total Acc", w - margin - 130, margin + 40);
        g2.setColor(Color.CYAN); g2.fillRect(w - margin - 150, margin + 50, 10, 10);
        g2.setColor(Color.WHITE); g2.drawString("Test Acc", w - margin - 130, margin + 60);
        g2.setColor(Color.MAGENTA); g2.fillRect(w - margin - 150, margin + 70, 10, 10);
        g2.setColor(Color.WHITE); g2.drawString("Test1 Acc", w - margin - 130, margin + 80);

        for (int d = 0; d < 10; d++) {
            g2.setColor(digitColors[d % digitColors.length]);
            g2.fillRect(w - margin - 150, margin + 100 + d * 20, 10, 10);
            g2.setColor(Color.WHITE);
            g2.drawString("Digit " + d, w - margin - 130, margin + 110 + d * 20);
        }
    }

    // Create window
    public static void createWindow(AccuracyVisualizer viz) {
        JFrame frame = new JFrame("Accuracy Visualizer");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setSize(900, 700);
        frame.setContentPane(viz);
        frame.setVisible(true);
    }
}

    // --- Helper to compute accuracy on a dataset (no CSV/logging) ---
    public static double computeAccuracy(List<double[]> inputs, List<Integer> labels,
                                         double[][] w1, double[] b1,
                                         double[][] w2, double[] b2,
                                         double[][] w3, double[] b3) {
        int correct = 0;
        for (int i = 0; i < inputs.size(); i++) {
            double[] x = inputs.get(i);
            int y = labels.get(i);
            double[] out = (double[]) forward(x, w1, b1, w2, b2, w3, b3, false).get("output");
            int pred = 0; double max = out[0];
            for (int j=1; j<out.length; j++) if (out[j] > max) { max = out[j]; pred = j; }
            if (pred == y) correct++;
        }
        return (inputs.isEmpty() ? 0.0 : (correct * 1.0 / inputs.size()));
    }

    // --- Training / main ---
    public static void main(String[] args) throws Exception {
        int inputSize = 28 * 28;
        int h1 = 4, h2 = 1;
        int outputSize = 10;
        double lr = 0.01;
        int batchSize = 128;
        double lambda = 0.0001;
        int maxEpochs = 128;

        Random rand = new Random();
        double[][] w1 = new double[inputSize][h1]; double[] b1 = new double[h1];
        double[][] w2 = new double[h1][h2];        double[] b2 = new double[h2];
        double[][] w3 = new double[h2][outputSize];double[] b3 = new double[outputSize];

        for(int i=0;i<inputSize;i++) for(int j=0;j<h1;j++) w1[i][j]=rand.nextGaussian()*Math.sqrt(2.0/inputSize);
        for(int j=0;j<h1;j++) b1[j]=0;
        for(int i=0;i<h1;i++) for(int j=0;j<h2;j++) w2[i][j]=rand.nextGaussian()*Math.sqrt(2.0/h1);
        for(int j=0;j<h2;j++) b2[j]=0;
        for(int i=0;i<h2;i++) for(int j=0;j<outputSize;j++) w3[i][j]=rand.nextGaussian()*Math.sqrt(2.0/h2);
        for(int j=0;j<outputSize;j++) b3[j]=0;

        // --- Load & combine training data ---
        List<double[]> trainInputs1 = loadInputs("Data/train.csv", inputSize);
        List<Integer>  trainLabels1 = loadLabels("Data/train.csv", inputSize);
        List<double[]> trainInputs2 = loadInputs("Data/train1.csv", inputSize);
        List<Integer>  trainLabels2 = loadLabels("Data/train1.csv", inputSize);

        List<double[]> trainInputs = new ArrayList<>();
        List<Integer>  trainLabels = new ArrayList<>();
        trainInputs.addAll(trainInputs1);
        trainLabels.addAll(trainLabels1);
        trainInputs.addAll(trainInputs2);
        trainLabels.addAll(trainLabels2);

        // --- Load test sets separately ---
        List<double[]> testInputs  = loadInputs("Data/test.csv",  inputSize);
        List<Integer>  testLabels  = loadLabels("Data/test.csv",  inputSize);
        List<double[]> testInputs1 = loadInputs("Data/test1.csv", inputSize);
        List<Integer>  testLabels1 = loadLabels("Data/test1.csv", inputSize);

        // --- GUI setup ---
        AccuracyVisualizer visualizer = new AccuracyVisualizer();

        // Add dummy data to test drawing
        visualizer.update(0, 0.5, 0.6, 0.4, new double[]{0.5,0.6,0.4,0.7,0.3,0.2,0.1,0.9,0.8,0.5});

        // Show the window
        SwingUtilities.invokeAndWait(() -> {
            JFrame frame = new JFrame("Accuracy Visualizer");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.setSize(1000, 700);
            frame.setLocationRelativeTo(null);
            frame.add(visualizer);
            frame.setVisible(true);
            
        });

        // --- CSV logging ---
        BufferedWriter csv = new BufferedWriter(new FileWriter("accuracy_logs.csv"));
        csv.write("epoch,dataset,totalAcc,d0,d1,d2,d3,d4,d5,d6,d7,d8,d9\n");

        // --- Training loop ---
        for (int epoch = 1; epoch <= maxEpochs; epoch++) {
            // Shuffle
            List<Integer> indices = new ArrayList<>();
            for (int i = 0; i < trainInputs.size(); i++) indices.add(i);
            Collections.shuffle(indices, rand);

            // Mini-batches
            for (int batchStart = 0; batchStart < trainInputs.size(); batchStart += batchSize) {
                int batchEnd = Math.min(batchStart + batchSize, trainInputs.size());
                int bs = batchEnd - batchStart;

                double[][] dW1 = new double[inputSize][h1]; double[] dB1 = new double[h1];
                double[][] dW2 = new double[h1][h2];        double[] dB2 = new double[h2];
                double[][] dW3 = new double[h2][outputSize];double[] dB3 = new double[outputSize];

                for (int idx = batchStart; idx < batchEnd; idx++) {
                    int i = indices.get(idx);
                    double[] x = trainInputs.get(i);
                    int y = trainLabels.get(i);

                    Map<String,Object> fwd = forward(x, w1, b1, w2, b2, w3, b3, true);
                    double[] h1v = (double[]) fwd.get("hidden1");
                    double[] h1Raw = (double[]) fwd.get("hidden1Raw");
                    double[] h2v = (double[]) fwd.get("hidden2");
                    double[] h2Raw = (double[]) fwd.get("hidden2Raw");
                    double[] out = (double[]) fwd.get("output");

                    double[] dOut = new double[outputSize];
                    for (int k = 0; k < outputSize; k++) dOut[k] = out[k] - (k == y ? 1 : 0);

                    for (int k = 0; k < outputSize; k++) {
                        dB3[k] += dOut[k];
                        for (int j = 0; j < h2; j++) dW3[j][k] += h2v[j] * dOut[k];
                    }

                    double[] dH2 = new double[h2];
                    for (int j = 0; j < h2; j++) {
                        double sum = 0;
                        for (int k = 0; k < outputSize; k++) sum += w3[j][k] * dOut[k];
                        dH2[j] = sum * reluDerivative(h2Raw[j]);
                    }

                    for (int j = 0; j < h2; j++) {
                        dB2[j] += dH2[j];
                        for (int i1 = 0; i1 < h1; i1++) dW2[i1][j] += h1v[i1] * dH2[j];
                    }

                    double[] dH1 = new double[h1];
                    for (int j = 0; j < h1; j++) {
                        double sum = 0;
                        for (int k = 0; k < h2; k++) sum += w2[j][k] * dH2[k];
                        dH1[j] = sum * reluDerivative(h1Raw[j]);
                    }

                    for (int j = 0; j < h1; j++) {
                        dB1[j] += dH1[j];
                        for (int i1 = 0; i1 < inputSize; i1++) dW1[i1][j] += x[i1] * dH1[j];
                    }
                }

                // Update (L2 regularization)
                for (int i=0;i<inputSize;i++) for (int j=0;j<h1;j++) w1[i][j] -= lr * (dW1[i][j]/bs + lambda * w1[i][j]);
                for (int j=0;j<h1;j++) b1[j] -= lr * dB1[j] / bs;
                for (int i=0;i<h1;i++) for (int j=0;j<h2;j++) w2[i][j] -= lr * (dW2[i][j]/bs + lambda * w2[i][j]);
                for (int j=0;j<h2;j++) b2[j] -= lr * dB2[j] / bs;
                for (int i=0;i<h2;i++) for (int j=0;j<outputSize;j++) w3[i][j] -= lr * (dW3[i][j]/bs + lambda * w3[i][j]);
                for (int j=0;j<outputSize;j++) b3[j] -= lr * dB3[j] / bs;
            }

            // --- End of epoch: evaluate and update GUI ---
            // Train accuracy (quick pass)
            // --- End of epoch: evaluate and update GUI ---
            double trainAccuracy = computeAccuracy(trainInputs, trainLabels, w1, b1, w2, b2, w3, b3);

            // Compute test set accuracies first
            double testAccuracy  = evaluateTestSet(testInputs,  testLabels,  w1, b1, w2, b2, w3, b3, csv, epoch, "test.csv");
            double test1Accuracy = evaluateTestSet(testInputs1, testLabels1, w1, b1, w2, b2, w3, b3, csv, epoch, "test1.csv");

            // Per-digit accuracy (array of 10 doubles, one per class 0–9)
            double[] perDigitAcc = computePerDigitAccuracy(testInputs, testLabels, w1, b1, w2, b2, w3, b3);

            // Update visualizer (pass all metrics)
            visualizer.update(epoch, trainAccuracy, testAccuracy, test1Accuracy, perDigitAcc);
        }
        csv.close();
        saveWeights("weights.dat", w1, b1, w2, b2, w3, b3);
        System.out.println("Training complete! Weights saved to weights.dat");
    }

}